const User= require('../models/user');
const {validationResult}= require('express-validator/check');
const bcrypt= require('bcryptjs');
const jwt= require('jsonwebtoken');
exports.signup= (req, res, next)=>{
    const errors= validationResult(req);
    if(!errors.isEmpty()){
        const error= new Error('Validation failed, Entered data is incorrect');
        error.statusCode= 422;
        error.data= errors.array();//this introduces a new field of data where data of errors are stored in array form.
        throw error;
    }
    const email= req.body.email;
    const password= req.body.password;
    const name= req.body.name;
    bcrypt.hash(password, 12)
    .then(hashedPw=>{
        const user= new User({
            email: email,
            password: hashedPw,
            name: name
        })
        return user.save();
    })
    .then(result=>{
        console.log(result);
        res.status(201).json({
            message: 'User Created !',
            userId: result._id
        })
    })
    .catch(err=>{
        if(!err.statusCode) err.statusCode= 500;
        next(err);
    })
}
exports.login= (req, res, next)=>{
    const email= req.body.email;
    const password= req.body.password;
    let loadedUser;
    User.findOne({email: email})
    .then(user=>{
        if(!user){
            const error= new Error('User not registered');
            error.statusCode= 401;//not authenticated.
            throw error;
        }
        loadedUser=user;
        return bcrypt.compare(password, user.password);//this results in true or false.
    })
    .then(isEqual=>{
        if(!isEqual){
            const error= new Error('Wrong Password');
            error.statusCode= 401;
            throw error;
        }
        //finally the req which makes up to here will require JWT->json web token(used for login purpose.)
        //jwt.sign()=>creates an new web token
        //string 'secret' is the secret key which is then hashed.
        const token= jwt.sign({
            email: loadedUser.email,//these information will be visible to the user.
            userId: loadedUser._id.toString()
        }, 'somesecret', {expiresIn: '2h'})//=>Since this token is generated by the server, when the current client leaves the browser without logging out then other user may steal this token.So for safety we will expire that token.
        res.status(200).json({
            token:token,//our front end is waiting for these information only.
            userId: loadedUser._id.toString()
        })
    })
    .catch(err=>{
        if(!err.statusCode) err.statusCode= 500;
        next(err);
    })
}
exports.getUserStatus= (req, res, next)=>{
    User.findById(req.userId)
    .then(user=>{
        if(!user){
            const error= new Error('User not registered');
            error.statusCode= 404;//not authenticated.
            throw error;
        }
        res.status(200).json({
            status: user.status
        })
    })
    .catch(err=>{
        if(!err.statusCode) err.statusCode= 500;
        next(err);
    })
}

exports.updateUserStatus=(req, res, next)=>{
    const newStatus= req.body.status;
    User.findById(req.userId)
    .then(user=>{
        if(!user){
            const error= new Error('User not registered');
            error.statusCode= 404;//not authenticated.
            throw error;
        }
        user.status=newStatus;
        return user.save();
    })
    .then(result=>{
        res.status(200).json({
            message: 'User Updated'
        })
    })
    .catch(err=>{
        if(!err.statusCode) err.statusCode= 500;
        next(err);
    })
}

//JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed.
// JWT can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.
//HMAC=>uses hashing concept twice and hence is resistant to hacking ie. most secured.